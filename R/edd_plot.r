#' @name edd_plot
#' @title Generating plots for a replicated edd simulation
#' @description Function to automatically generate several plots from raw data
#' of a replicated edd simulation
#' @param raw_data a list of results generated by edd simulation function
#' @param which Which part of data to be plotted
#' @param save_plot Logical, decides whether to save the plots to files
#' @param strategy Determine if the simulation is sequential or multi-sessioned
#' or multi-cored
#' @param workers Determine how many sessions are participated in the simulation
#' @param verbose Logical, decides whether to print loading details
#' @return a plot pack containing several plots
#' @author Tianjian Qin
#' @keywords phylogenetics
#' @export edd_plot
edd_plot <- function(raw_data = NULL,
                     which = "all",
                     save_plot = FALSE,
                     path = NULL,
                     strategy = "sequential",
                     workers = 1,
                     verbose = TRUE) {
  check_parallel_arguments(strategy, workers, verbose)
  check_raw_data(raw_data$data)
  plots <- list()
  message(paste0("Generating plots for ", which))

  if (save_plot == TRUE) {
    message("Saving plots to files")
  }

  # plot normalized lineages through time
  #if ("all" %in% which | "nltt" %in% which) {
  #  plot_nltt <- lapply(raw_data$data, edd_plot_nltt, save_plot = save_plot, path = path)
  #  plots <- list(plots, plot_nltt)
  #}

  # plot lineages through time
  if ("all" %in% which | "ltt" %in% which) {
    plot_ltt <- lapply(raw_data$data, edd_plot_ltt, save_plot = save_plot, path = path)
    plots <- list(plots, plot_ltt)
  }

  if ("all" %in% which | "grouped_ltt" %in% which) {
    plot_grouped_ltt <- edd_plot_grouped_ltt(raw_data, save_plot = save_plot, path = path)
    plots <- list(plots, plot_grouped_ltt)
  }

  # plot speciation rates
  if ("all" %in% which | "las" %in% which) {
    plot_las <- lapply(raw_data$data, edd_plot_las, save_plot = save_plot, path = path)
    plots <- list(plots, plot_las)
  }

  if ("all" %in% which | "grouped_las" %in% which) {
    plot_grouped_las <- edd_plot_grouped_las(raw_data, save_plot = save_plot, path = path)
    plots <- list(plots, plot_grouped_las)
  }

  # plot extinction rates
  if ("all" %in% which | "mus" %in% which) {
    plot_mus <- lapply(raw_data$data, edd_plot_mus, save_plot = save_plot, path = path)
    plots <- list(plots, plot_mus)
  }

  if ("all" %in% which | "grouped_mus" %in% which) {
    plot_grouped_mus <- edd_plot_grouped_mus(raw_data, save_plot = save_plot, path = path)
    plots <- list(plots, plot_grouped_mus)
  }

  # plot evolutionary distinctiveness-es
  if ("all" %in% which | "eds" %in% which) {
    plot_eds <- lapply(raw_data$data, edd_plot_eds, save_plot = save_plot, path = path)
    plots <- list(plots, plot_eds)
  }

  if ("all" %in% which | "grouped_eds" %in% which) {
    plot_grouped_eds <- edd_plot_grouped_eds(raw_data, save_plot = save_plot, path = path)
    plots <- list(plots, plot_grouped_eds)
  }

  if ("all" %in% which | "balance" %in% which) {
    plot_balance <- edd_plot_balance(raw_data, save_plot = save_plot, path = path)
    plots <- list(plots, plot_balance)
  }

  if ("all" %in% which | "branch" %in% which) {
    plot_balance <- edd_plot_branch(raw_data, save_plot = save_plot, path = path)
    plots <- list(plots, plot_balance)
  }

  if (save_plot != TRUE) {
    message("Plots are not saved, returning ggplot2 objects as a list")
    return(plots)
  }
}

#' @name edd_plot_nltt
#' @title Generating nLTT plot for a replicated edd simulation
#' @description Function to generate normalized lineages through time plot from
#' raw data of a replicated edd simulation
#' @param raw_data a list of results generated by edd simulation function
#' @param drop_extinct Logical, decides whether to drop extinct lineages
#' @param save_plot Logical, decides whether to save the plots to files
#' @return an plot object
#' @author Tianjian Qin
#' @keywords phylogenetics
#' @export edd_plot_nltt
edd_plot_nltt <- function(raw_data = NULL,
                          drop_extinct = TRUE,
                          save_plot = FALSE,
                          path = NULL
) {
  if (drop_extinct == TRUE) {
    message("Drawing nLTT plot with trees of extant species")
    df <- nLTT::get_nltt_values(raw_data$tes, dt = 0.01)
  } else {
    message("Drawing nLTT plot with trees of all species")
    df <- nLTT::get_nltt_values(raw_data$tas, dt = 0.01)
  }

  pars_list <- extract_parameters(raw_data)
  anno <- create_annotation(pars_list, vjust = c(1, 2.1))

  plot_nltt <-
    ggplot2::ggplot() +
      ggplot2::geom_point(data = df,
                          ggplot2::aes(t, nltt, color = id),
                          size = I(0.1)) +
      ggplot2::stat_summary(data = df,
                            ggplot2::aes(t, nltt),
                            fun.data = ggplot2::mean_cl_boot,
                            geom = "smooth") +
      ggplot2::ggtitle("Average nLTT plot of phylogenies") +
      ggplot2::labs(x = "Normalized time", y = "Normalized number of lineages") +
      #scale_colour_ggthemr_d() +
      ggtext::geom_richtext(
        data = anno,
        ggplot2::aes(
          x,
          y,
          label = label,
          angle = angle,
          hjust = hjust,
          vjust = vjust
        ),
        fill = "#E8CB9C"
      ) +
      viridis::scale_colour_viridis(discrete = TRUE, option = "A") +
      ggplot2::xlim(0, 1) +
      ggplot2::ylim(0, 1) +
      ggplot2::theme(legend.position = "none",
                     aspect.ratio = 3 / 4)

  if (save_plot == TRUE) {
    save_with_parameters(pars_list = pars_list,
                         plot = plot_nltt,
                         which = "nltt",
                         path = path,
                         device = "png",
                         width = 5,
                         height = 4,
                         dpi = "retina")
  } else {
    return(plot_nltt)
  }
}


#' @name edd_plot_ltt
#' @title Generating LTT plot for a replicated edd simulation
#' @description Function to generate lineages through time plot from
#' raw data of a replicated edd simulation
#' @param raw_data a list of results generated by edd simulation function
#' @param alpha Resolution of the confidence interval
#' @param save_plot true or false, to decide whether to save the plots to files
#' @return an plot object
#' @author Tianjian Qin
#' @keywords phylogenetics
#' @export edd_plot_ltt
edd_plot_ltt <-
  function(raw_data = NULL,
           alpha = 0.05,
           save_plot = FALSE,
           path = NULL
  ) {
    pars_list <- extract_parameters(raw_data)

    brts <- lapply(raw_data$l_tables, function(x) {
      x[-1, 1]
    })

    ts <- unlist(brts)
    ts <- unique(ts)
    ts <- sort(ts)

    df <- calculate_CI(brts, ts, alpha = alpha)
    colnames(df) <- c("t", "median", "minalpha", "maxalpha", "mean")
    df <- as.data.frame(df)

    anno <- create_annotation(pars_list, vjust = c(1, 2.1))

    plot_ltt <-
      ggplot2::ggplot(df) +
        ggplot2::geom_line(ggplot2::aes(t, mean)) +
        ggplot2::geom_ribbon(ggplot2::aes(t, mean, ymax =
          maxalpha, ymin = minalpha), alpha = 0.2) +
        ggplot2::ggtitle("Lineage-Through-Time Plot") +
        ggplot2::theme(legend.position = "none",
                       aspect.ratio = 3 / 4) +
        ggplot2::xlab("Time") +
        ggplot2::ylab("Number of lineages") +
        ggplot2::scale_y_continuous(trans = 'log10') +
        ggtext::geom_richtext(
          data = anno,
          ggplot2::aes(
            x = x,
            y = y,
            label = label,
            angle = angle,
            hjust = hjust,
            vjust = vjust
          ),
          fill = "#E8CB9C"
        )

    if (save_plot == TRUE) {
      save_with_parameters(pars_list = pars_list,
                           plot = plot_ltt,
                           which = "ltt",
                           path = path,
                           device = "png",
                           width = 5,
                           height = 4,
                           dpi = "retina")
    } else {
      return(plot_ltt)
    }
  }



#' @name edd_plot_grouped_ltt
#' @title Generating LTT plot for a replicated edd simulation
#' @description Function to generate grouped lineages through time plot from
#' raw data of a replicated edd simulation
#' @param raw_data a list of results generated by edd simulation function
#' @param group specify the group to plot
#' @param save_plot Logical, whether save to file or return a ggplot object
#' @return an ggplot object
#' @author Tianjian Qin
#' @keywords phylogenetics
#' @export edd_plot_grouped_ltt
#' @importFrom magrittr %>%
#' @import patchwork
edd_plot_grouped_ltt <- function(raw_data = NULL, group = "metric", save_plot = FALSE, path = NULL) {
  tally <- tally_by_group(raw_data, group)
  indexes <- create_indexes_by_group(tally)
  grouped_ltt <- lapply(indexes, function(x) {
    plots <- lapply(x, function(y) edd_plot_ltt(raw_data$data[[y]], save_plot = FALSE))
    grouped_plot <- patchwork::wrap_plots(plots, ncol = 1)
    if (save_plot == TRUE) {
      pars_list <-  extract_parameters(raw_data$data[[x[1]]])
      save_with_parameters(pars_list = pars_list,
                           plot = grouped_plot,
                           which = "grouped_ltt",
                           path = path,
                           device = "png",
                           width = 10,
                           height = 4 * tally$groups,
                           dpi = "retina")
    }
  })
}



#' @name edd_plot_las
#' @title Generating line plot of speciation rates of each lineage
#' @description Function to generate a plot showing the transition of speciation
#' rates of each lineage
#' @param raw_data a list of results generated by edd simulation function
#' @param rep_id specify the id of replication to plot
#' @param save_plot Logical, whether save to file or return a ggplot object
#' @return an ggplot object
#' @author Tianjian Qin
#' @keywords phylogenetics
#' @export edd_plot_las
#' @importFrom magrittr %>%
#' @import patchwork
edd_plot_las <- function(raw_data = NULL, rep_id = 1, save_plot = FALSE, path = NULL) {
  pars_list <- extract_parameters(raw_data)

  las_table <- cbind(Time = raw_data$ltt[[rep_id]]$time, raw_data$las[[rep_id]])
  las_long <-
    las_table %>%
      tidyr::gather("Tip", "Lambda", -Time) %>%
      na.omit()
  las_long <- las_long %>%
    dplyr::group_by(Time) %>%
    dplyr::mutate(Deviation = Lambda - mean(Lambda))

  anno <- create_annotation(pars_list, y = c(-Inf, -Inf), vjust = c(-1, 0))

  plot_las1 <- ggplot2::ggplot(las_long) +
    ggplot2::geom_path(ggplot2::aes(Time, Lambda, group = Tip, color = Lambda)) +
    viridis::scale_color_viridis(option = "D") +
    ggtext::geom_richtext(
      data = anno,
      ggplot2::aes(
        x = x,
        y = y,
        label = label,
        angle = angle,
        hjust = hjust,
        vjust = vjust
      ),
      fill = "#E8CB9C"
    ) +
    ggplot2::theme(legend.position = "none",
                   aspect.ratio = 1 / 1)

  plot_las2 <- ggplot2::ggplot(las_long) +
    ggplot2::geom_path(ggplot2::aes(Time, Deviation, group = Tip, color = Lambda)) +
    viridis::scale_color_viridis(option = "D") +
    ggplot2::geom_hline(yintercept = 0,
                        linetype = "twodash",
                        color = "grey") +
    ggplot2::theme(legend.position = "right",
                   aspect.ratio = 1 / 1)

  plot_las <- plot_las1 + plot_las2

  if (save_plot == TRUE) {
    save_with_parameters(pars_list = pars_list,
                         plot = plot_las,
                         which = "las",
                         path = path,
                         device = "png",
                         width = 10,
                         height = 8,
                         dpi = "retina")
  } else {
    return(plot_las)
  }
}

#' @name edd_plot_grouped_las
#' @title Generating line plot of speciation rates of each lineage by group
#' @description Function to generate a plot showing the transition of speciation
#' rates of each lineage by specified group
#' @param raw_data a list of results generated by edd simulation function
#' @param group specify the group to plot
#' @param save_plot Logical, whether save to file or return a ggplot object
#' @return an ggplot object
#' @author Tianjian Qin
#' @keywords phylogenetics
#' @export edd_plot_grouped_las
#' @importFrom magrittr %>%
#' @import patchwork
edd_plot_grouped_las <- function(raw_data = NULL, group = "metric", save_plot = FALSE, path = NULL) {
  tally <- tally_by_group(raw_data, group)
  indexes <- create_indexes_by_group(tally)
  grouped_las <- lapply(indexes, function(x) {
    plots <- lapply(x, function(y) edd_plot_las(raw_data$data[[y]], save_plot = FALSE))
    grouped_plot <- patchwork::wrap_plots(plots, ncol = 1)
    if (save_plot == TRUE) {
      pars_list <- extract_parameters(raw_data$data[[x[1]]])
      save_with_parameters(pars_list = pars_list,
                           plot = grouped_plot,
                           which = "grouped_las",
                           path = path,
                           device = "png",
                           width = 10,
                           height = 4 * tally$groups,
                           dpi = "retina")
    }
  })
}



#' @name edd_plot_mus
#' @title Generating line plot of extinction rates of each lineage
#' @description Function to generate a plot showing the transition of extinction
#' rates of each lineage
#' @param raw_data a list of results generated by edd simulation function
#' @param rep_id specify the id of replication to plot
#' @param save_plot Logical, whether save to file or return a ggplot object
#' @return an ggplot object
#' @author Tianjian Qin
#' @keywords phylogenetics
#' @export edd_plot_mus
#' @importFrom magrittr %>%
#' @import patchwork
edd_plot_mus <- function(raw_data = NULL, rep_id = 1, save_plot = FALSE, path = NULL) {
  pars_list <- extract_parameters(raw_data)

  mus_table <- cbind(Time = raw_data$ltt[[rep_id]]$time, raw_data$mus[[rep_id]])
  mus_long <-
    mus_table %>%
      tidyr::gather("Tip", "Mu", -Time) %>%
      na.omit()
  mus_long <- mus_long %>%
    dplyr::group_by(Time) %>%
    dplyr::mutate(Deviation = Mu - mean(Mu))

  anno <- create_annotation(pars_list, y = c(-Inf, -Inf), vjust = c(-0.8, 0))

  plot_mus1 <- ggplot2::ggplot(mus_long) +
    ggplot2::geom_path(ggplot2::aes(Time, Mu, group = Tip, color = Mu)) +
    viridis::scale_color_viridis(option = "D") +
    ggtext::geom_richtext(
      data = anno,
      ggplot2::aes(
        x = x,
        y = y,
        label = label,
        angle = angle,
        hjust = hjust,
        vjust = vjust
      ),
      fill = "#E8CB9C"
    ) +
    ggplot2::theme(legend.position = "none",
                   aspect.ratio = 1 / 1)

  plot_mus2 <- ggplot2::ggplot(mus_long) +
    ggplot2::geom_path(ggplot2::aes(Time, Deviation, group = Tip, color = Mu)) +
    viridis::scale_color_viridis(option = "D") +
    ggplot2::geom_hline(yintercept = 0,
                        linetype = "twodash",
                        color = "grey") +
    ggplot2::theme(legend.position = "right",
                   aspect.ratio = 1 / 1)

  plot_mus <- plot_mus1 + plot_mus2

  if (save_plot == TRUE) {
    save_with_parameters(pars_list = pars_list,
                         plot = plot_mus,
                         which = "mus",
                         path = path,
                         device = "png",
                         width = 10,
                         height = 8,
                         dpi = "retina")
  } else {
    return(plot_mus)
  }
}



#' @name edd_plot_grouped_mus
#' @title Generating line plot of extinction rates of each lineage by group
#' @description Function to generate a plot showing the transition of extinction
#' rates of each lineage by specified group
#' @param raw_data a list of results generated by edd simulation function
#' @param group specify the group to plot
#' @param save_plot Logical, whether save to file or return a ggplot object
#' @return an ggplot object
#' @author Tianjian Qin
#' @keywords phylogenetics
#' @export edd_plot_grouped_mus
#' @importFrom magrittr %>%
#' @import patchwork
edd_plot_grouped_mus <- function(raw_data = NULL, group = "metric", save_plot = FALSE, path = NULL) {
  tally <- tally_by_group(raw_data, group)
  indexes <- create_indexes_by_group(tally)
  grouped_mus <- lapply(indexes, function(x) {
    plots <- lapply(x, function(y) edd_plot_mus(raw_data$data[[y]], save_plot = FALSE))
    grouped_plot <- patchwork::wrap_plots(plots, ncol = 1)
    if (save_plot == TRUE) {
      pars_list <- extract_parameters(raw_data$data[[x[1]]])
      save_with_parameters(pars_list = pars_list,
                           plot = grouped_plot,
                           which = "grouped_mus",
                           path = path,
                           device = "png",
                           width = 10,
                           height = 4 * tally$groups,
                           dpi = "retina")
    }
  })
}




#' @name edd_plot_eds
#' @title Generating line plot of evolutionary distinctiveness of each lineage
#' @description Function to generate a plot showing the transition of evolutionary
#' distinctiveness of each lineage
#' @param raw_data a list of results generated by edd simulation function
#' @param rep_id specify the id of replication to plot
#' @param save_plot Logical, whether save to file or return a ggplot object
#' @return an ggplot object
#' @author Tianjian Qin
#' @keywords phylogenetics
#' @export edd_plot_eds
#' @importFrom magrittr %>%
#' @import patchwork
edd_plot_eds <- function(raw_data = NULL, rep_id = 1, save_plot = FALSE, path = NULL) {
  pars_list <- extract_parameters(raw_data)

  eds_table <- cbind(Time = raw_data$ltt[[rep_id]]$time, raw_data$eds[[rep_id]])
  eds_long <-
    eds_table %>%
      tidyr::gather("Tip", "ED", -Time) %>%
      na.omit()
  eds_long <- eds_long %>%
    dplyr::group_by(Time) %>%
    dplyr::mutate(Deviation = ED - mean(ED))

  anno <- create_annotation(pars_list, y = c(Inf, Inf), vjust = c(1, 2.1))

  plot_eds1 <- ggplot2::ggplot(eds_long) +
    ggplot2::geom_path(ggplot2::aes(Time, ED, group = Tip, color = ED)) +
    viridis::scale_color_viridis(option = "D") +
    ggtext::geom_richtext(
      data = anno,
      ggplot2::aes(
        x = x,
        y = y,
        label = label,
        angle = angle,
        hjust = hjust,
        vjust = vjust
      ),
      fill = "#E8CB9C"
    ) +
    ggplot2::theme(legend.position = "none",
                   aspect.ratio = 1 / 1)

  plot_eds2 <- ggplot2::ggplot(eds_long) +
    ggplot2::geom_path(ggplot2::aes(Time, Deviation, group = Tip, color = ED)) +
    viridis::scale_color_viridis(option = "D") +
    ggplot2::geom_hline(yintercept = 0,
                        linetype = "twodash",
                        color = "grey") +
    ggplot2::theme(legend.position = "right",
                   aspect.ratio = 1 / 1)

  plot_eds <- plot_eds1 + plot_eds2

  if (save_plot == TRUE) {
    save_with_parameters(pars_list = pars_list,
                         plot = plot_eds,
                         which = "eds",
                         path = path,
                         device = "png",
                         width = 10,
                         height = 8,
                         dpi = "retina")
  } else {
    return(plot_eds)
  }
}



#' @name edd_plot_grouped_eds
#' @title Generating line plot of evolutionary distinctiveness of each lineage by group
#' @description Function to generate a plot showing the transition of evolutionary distinctiveness
#' of each lineage by specified group
#' @param raw_data a list of results generated by edd simulation function
#' @param group specify the group to plot
#' @param save_plot Logical, whether save to file or return a ggplot object
#' @return an ggplot object
#' @author Tianjian Qin
#' @keywords phylogenetics
#' @export edd_plot_grouped_eds
#' @importFrom magrittr %>%
#' @import patchwork
edd_plot_grouped_eds <- function(raw_data = NULL, group = "metric", save_plot = FALSE, path = NULL) {
  tally <- tally_by_group(raw_data, group)
  indexes <- create_indexes_by_group(tally)
  grouped_eds <- lapply(indexes, function(x) {
    plots <- lapply(x, function(y) edd_plot_eds(raw_data$data[[y]], save_plot = FALSE))
    grouped_plot <- patchwork::wrap_plots(plots, ncol = 1)
    if (save_plot == TRUE) {
      pars_list <- extract_parameters(raw_data$data[[x[1]]])
      save_with_parameters(pars_list = pars_list,
                           plot = grouped_plot,
                           which = "grouped_eds",
                           path = path,
                           device = "png",
                           width = 10,
                           height = 4 * tally$groups,
                           dpi = "retina")
    }
  })
}



#' @name edd_plot_balance
#' @title Generating boxplots of tree balance indices
#' @description Function to generate boxplots showing the tree balance indices (Sackin, Colless and Blum indices)
#' @param raw_data  a list of results generated by edd simulation function
#' @param method Specify which package to be used to calculate calculate statistics
#' @param save_plot Logical, whether save to file or return a ggplot object
#' @return an ggplot object
#' @author Tianjian Qin
#' @keywords phylogenetics
#' @export edd_plot_balance
edd_plot_balance <- function(raw_data = NULL, method = "treestats", save_plot = FALSE, path = NULL) {
  stat_balance <- edd_stat(raw_data$data, stat = "balance", method = method)
  stat_balance <- tidyr::gather(stat_balance, key = "balance", value = "value", sackin, colless, blum)
  stat_balance <- transform_data(stat_balance)

  lambdas <- levels(stat_balance$lambda)
  mus <- levels(stat_balance$mu)
  rates <- expand.grid(lambdas, mus)

  plot_significance <- lapply(split(raw_data$params, seq(nrow(raw_data$params))), edd_plot_balance_significance, stat_balance = stat_balance, save_plot = save_plot, path = path)
  plot_pd_offsets <- apply(rates, 1, edd_plot_balance_pd_offsets, stat_balance = stat_balance, params = raw_data$params, save_plot = save_plot, path = path)
  plot_pd_ed_none <- apply(rates, 1, edd_plot_balance_pd_ed, stat_balance = stat_balance, params = raw_data$params, offset = "None", save_plot = save_plot, path = path)
  plot_pd_ed_simtime <- apply(rates, 1, edd_plot_balance_pd_ed, stat_balance = stat_balance, params = raw_data$params, offset = "Simulation time", save_plot = save_plot, path = path)
  plot_pd_ed_spcount <- apply(rates, 1, edd_plot_balance_pd_ed, stat_balance = stat_balance, params = raw_data$params, offset = "Species count", save_plot = save_plot, path = path)

  if (save_plot != TRUE) {
    return(list(significance = plot_significance,
                pd_pffsets = plot_pd_offsets,
                pd_none_ed = plot_pd_ed_none,
                pd_simetime_ed = plot_pd_ed_simtime,
                pd_spcount_ed = plot_pd_ed_spcount))
  }
}



edd_plot_balance_pd_offsets <- function(rates, stat_balance, params, save_plot = FALSE, path = NULL) {
  lambda_num <- rates[1]
  mu_num <- rates[2]

  lambda <- as.character(rates[1])
  mu <- as.character(rates[2])

  plot_data <- dplyr::filter(stat_balance,
                             lambda == lambda_num &
                               mu == mu_num &
                               metric == "pd")

  blum_plot <- ggplot2::ggplot(dplyr::filter(plot_data, balance == "blum")) +
    ggplot2::geom_boxplot(ggplot2::aes(beta_phi, value, fill = beta_n)) +
    ggplot2::facet_wrap(. ~ offset, nrow = 1) +
    ggplot2::scale_y_continuous(trans = "sqrt") +
    ggplot2::ylab("Blum") +
    ggplot2::theme(axis.title.x = ggplot2::element_blank(),
                   axis.text.x = ggplot2::element_blank(),
                   axis.ticks.x = ggplot2::element_blank(),
                   axis.line.x = ggplot2::element_blank())

  colless_plot <- ggplot2::ggplot(dplyr::filter(plot_data, balance == "colless")) +
    ggplot2::geom_boxplot(ggplot2::aes(beta_phi, value, fill = beta_n)) +
    ggplot2::facet_wrap(. ~ offset, nrow = 1) +
    ggplot2::scale_y_continuous() +
    ggplot2::ylab("Colless (Yule)") +
    ggplot2::theme(axis.title.x = ggplot2::element_blank(),
                   axis.text.x = ggplot2::element_blank(),
                   axis.ticks.x = ggplot2::element_blank(),
                   strip.background = ggplot2::element_blank(),
                   strip.text.x = ggplot2::element_blank(),
                   axis.line.x = ggplot2::element_blank())

  sackin_plot <- ggplot2::ggplot(dplyr::filter(plot_data, balance == "sackin")) +
    ggplot2::geom_boxplot(ggplot2::aes(beta_phi, value, fill = beta_n)) +
    ggplot2::facet_wrap(. ~ offset, nrow = 1) +
    ggplot2::scale_y_continuous() +
    ggplot2::scale_x_discrete(labels = format(unique(params$beta_phi), scientific = FALSE)) +
    ggplot2::ylab("Sackin (Yule)") +
    ggplot2::xlab(expression(beta[italic(Phi)])) +
    ggplot2::theme(strip.background = ggplot2::element_blank(),
                   strip.text.x = ggplot2::element_blank())

  # Tree Balance indices by Beta_Phi, . ~ Offset, grouped by Beta_N
  pd_offsets_plot <- blum_plot +
    ggplot2::ggtitle(bquote("Tree Balance indices of PD, comparisions between offset methods, " ~ lambda ~ "=" ~ .(lambda) ~ mu ~ "=" ~ .(mu))) +
    colless_plot +
    sackin_plot +
    patchwork::plot_layout(ncol = 1, guides = "collect") &
    ggplot2::labs(fill = expression(beta[italic(N)]))

  if (save_plot == TRUE) {
    save_with_rates(rates = rates,
                    plot = pd_offsets_plot,
                    which = "balance_pd_offsets",
                    path = path,
                    device = "png",
                    width = 10, height = 8,
                    dpi = "retina")
  } else {
    return(pd_offsets_plot)
  }
}


edd_plot_balance_pd_ed <- function(rates, stat_balance, params, offset = NULL, save_plot = FALSE, path = NULL) {
  lambda_num <- rates[1]
  mu_num <- rates[2]

  lambda <- as.character(rates[1])
  mu <- as.character(rates[2])
  offset_char <- as.character(offset)

  plot_data_pd <- dplyr::filter(stat_balance,
                                lambda == lambda_num &
                                  mu == mu_num &
                                  metric == "pd" &
                                  offset == offset_char)

  plot_data_ed <- dplyr::filter(stat_balance,
                                lambda == lambda_num &
                                  mu == mu_num &
                                  metric == "ed")

  plot_data_nnd <- dplyr::filter(stat_balance,
                                lambda == lambda_num &
                                  mu == mu_num &
                                  metric == "nnd")

  plot_data <- rbind(plot_data_pd, plot_data_ed, plot_data_nnd)

  plot_data_blum <- dplyr::filter(plot_data, balance == "blum")
  plot_data_colless <- dplyr::filter(plot_data, balance == "colless")
  plot_data_sackin <- dplyr::filter(plot_data, balance == "sackin")

  blum_plot <- ggplot2::ggplot(plot_data_blum) +
    ggplot2::geom_boxplot(ggplot2::aes(beta_phi, value, fill = metric)) +
    ggplot2::facet_wrap(. ~ beta_n) +
    ggplot2::scale_y_continuous(trans = "sqrt") +
    ggplot2::ylab("Blum") +
    ggplot2::theme(axis.title.x = ggplot2::element_blank(),
                   axis.text.x = ggplot2::element_blank(),
                   axis.ticks.x = ggplot2::element_blank(),
                   axis.line.x = ggplot2::element_blank())

  colless_plot <- ggplot2::ggplot(plot_data_colless) +
    ggplot2::geom_boxplot(ggplot2::aes(beta_phi, value, fill = metric)) +
    ggplot2::facet_wrap(. ~ beta_n) +
    #ggplot2::scale_y_continuous(trans = "sqrt") +
    ggplot2::ylab("Colless (Yule)") +
    ggplot2::theme(axis.title.x = ggplot2::element_blank(),
                   axis.text.x = ggplot2::element_blank(),
                   axis.ticks.x = ggplot2::element_blank(),
                   axis.line.x = ggplot2::element_blank(),
                   strip.background = ggplot2::element_blank(),
                   strip.text.x = ggplot2::element_blank())

  sackin_plot <- ggplot2::ggplot(plot_data_sackin) +
    ggplot2::geom_boxplot(ggplot2::aes(beta_phi, value, fill = metric)) +
    ggplot2::facet_wrap(. ~ beta_n) +
    #ggplot2::scale_y_continuous(trans = "sqrt") +
    ggplot2::scale_x_discrete(labels = format(unique(params$beta_phi), scientific = FALSE)) +
    ggplot2::ylab("Sackin (Yule)") +
    ggplot2::xlab(expression(beta[italic(Phi)])) +
    ggplot2::theme(strip.background = ggplot2::element_blank(),
                   strip.text.x = ggplot2::element_blank())

  pd_ed_plot <- blum_plot +
    ggplot2::ggtitle(bquote("Tree Balance indices, comparisons between PD (" ~ .(offset) ~ "), ED and NND, " ~ lambda ~ "=" ~ .(lambda) ~ mu ~ "=" ~ .(mu))) +
    colless_plot +
    sackin_plot +
    patchwork::plot_layout(nrow = 3, guides = "collect") &
    ggplot2::labs(fill = "Metric")

  if (save_plot == TRUE) {
    save_with_rates_offset(rates = rates,
                           offset = offset,
                           plot = pd_ed_plot,
                           which = "balance_pd_ed",
                           path = path,
                           device = "png",
                           width = 10, height = 8,
                           dpi = "retina")
  } else {
    return(pd_ed_plot)
  }
}



edd_plot_balance_significance <- function(params, stat_balance, save_plot = FALSE, path = NULL) {
  plot_data <- stat_balance %>%
    dplyr::filter(!(metric == "pd" & offset != "Simulation time")) %>%
    dplyr::filter(lambda == params$lambda & mu == params$mu & beta_n == params$beta_n & beta_phi == params$beta_phi)
  plot_balance <- ggstatsplot::grouped_ggbetweenstats(x = metric,
                                                      y = value,
                                                      data = plot_data,
                                                      grouping.var = balance,
                                                      pairwise.comparisons = FALSE,
                                                      results.subtitle = FALSE,
                                                      subtitle = FALSE,
                                                      bf.message = FALSE,
                                                      caption = FALSE)

  if (save_plot == TRUE) {
    save_with_parameters(pars_list = params,
                         plot = plot_balance,
                         which = "balance_signif",
                         path = path,
                         device = "png",
                         width = 12,
                         height = 5,
                         dpi = "retina")
  } else {
    return(plot_balance)
  }
}



#' @name edd_plot_branch
#' @title Generating boxplots of various tree branching measures
#' @description Function to generate boxplots showing the meaning branch lengths of the trees.
#' @param raw_data  a list of results generated by edd simulation function
#' @param method Specify which package to be used to calculate statistics
#' @param save_plot Logical, whether save to file or return a ggplot object
#' @return an ggplot object
#' @author Tianjian Qin
#' @keywords phylogenetics
#' @export edd_plot_branch
edd_plot_branch <- function(raw_data = NULL, method = "treestats", save_plot = FALSE, path = NULL) {
  stat_branch <- edd_stat(raw_data$data, stat = c("mbl", "pd", "mntd"), method = method)
  stat_branch <- transform_data(stat_branch)

  lambdas <- levels(stat_branch$lambda)
  mus <- levels(stat_branch$mu)
  rates <- expand.grid(lambdas, mus)

  plot_significance <- lapply(split(raw_data$params, seq(nrow(raw_data$params))), edd_plot_branch_significance, stat_branch = stat_branch, save_plot = save_plot, path = path)
  plot_pd_offsets <- apply(rates, 1, edd_plot_branch_pd_offsets, stat_branch = stat_branch, params = raw_data$params, save_plot = save_plot, path = path)
  plot_pd_ed_none <- apply(rates, 1, edd_plot_branch_pd_ed, stat_branch = stat_branch, params = raw_data$params, offset = "None", save_plot = save_plot, path = path)
  plot_pd_ed_simtime <- apply(rates, 1, edd_plot_branch_pd_ed, stat_branch = stat_branch, params = raw_data$params, offset = "Simulation time", save_plot = save_plot, path = path)
  plot_pd_ed_spcount <- apply(rates, 1, edd_plot_branch_pd_ed, stat_branch = stat_branch, params = raw_data$params, offset = "Species count", save_plot = save_plot, path = path)

  if (save_plot != TRUE) {
    return(list(significance = plot_significance,
                pd_pffsets = plot_pd_offsets,
                pd_none_ed = plot_pd_ed_none,
                pd_simetime_ed = plot_pd_ed_simtime,
                pd_spcount_ed = plot_pd_ed_spcount))
  }
}



edd_plot_branch_pd_offsets <- function(rates, stat_branch, params, save_plot = FALSE, path = NULL) {
  lambda_num <- rates[1]
  mu_num <- rates[2]

  lambda <- as.character(rates[1])
  mu <- as.character(rates[2])

  plot_data <- dplyr::filter(stat_branch,
                             lambda == lambda_num &
                               mu == mu_num &
                               metric == "pd")

  mbl_plot <- ggplot2::ggplot(data = plot_data) +
    ggplot2::geom_boxplot(ggplot2::aes(beta_phi, mbl, fill = beta_n)) +
    ggplot2::facet_wrap(. ~ offset, nrow = 1) +
    ggplot2::scale_y_continuous() +
    ggplot2::ylab("Mean branch length") +
    ggplot2::theme(axis.title.x = ggplot2::element_blank(),
                   axis.text.x = ggplot2::element_blank(),
                   axis.ticks.x = ggplot2::element_blank(),
                   axis.line.x = ggplot2::element_blank())

  pd_plot <- ggplot2::ggplot(data = plot_data) +
    ggplot2::geom_boxplot(ggplot2::aes(beta_phi, pd, fill = beta_n)) +
    ggplot2::facet_wrap(. ~ offset, nrow = 1) +
    ggplot2::scale_y_continuous(trans = "log2") +
    ggplot2::ylab("Phylogenetic diversity") +
    ggplot2::theme(axis.title.x = ggplot2::element_blank(),
                   axis.text.x = ggplot2::element_blank(),
                   axis.ticks.x = ggplot2::element_blank(),
                   strip.background = ggplot2::element_blank(),
                   strip.text.x = ggplot2::element_blank(),
                   axis.line.x = ggplot2::element_blank())

  mntd_plot <- ggplot2::ggplot(data = plot_data) +
    ggplot2::geom_boxplot(ggplot2::aes(beta_phi, mntd, fill = beta_n)) +
    ggplot2::facet_wrap(. ~ offset, nrow = 1) +
    ggplot2::scale_y_continuous() +
    ggplot2::scale_x_discrete(labels = format(unique(params$beta_phi), scientific = FALSE)) +
    ggplot2::ylab("Mean nearest taxon index") +
    ggplot2::xlab(expression(beta[italic(Phi)])) +
    ggplot2::theme(strip.background = ggplot2::element_blank(),
                   strip.text.x = ggplot2::element_blank())

  # Tree Balance indices by Beta_Phi, . ~ Offset, grouped by Beta_N
  pd_offsets_plot <- mbl_plot +
    ggplot2::ggtitle(bquote("Branching metrices of PD, comparisions between offset methods, " ~ lambda ~ "=" ~ .(lambda) ~ mu ~ "=" ~ .(mu))) +
    pd_plot +
    mntd_plot +
    patchwork::plot_layout(ncol = 1, guides = "collect") &
    ggplot2::labs(fill = expression(beta[italic(N)]))

  if (save_plot == TRUE) {
    save_with_rates(rates = rates,
                    plot = pd_offsets_plot,
                    which = "branch_pd_offsets",
                    path = path,
                    device = "png",
                    width = 10, height = 8,
                    dpi = "retina")
  } else {
    return(pd_offsets_plot)
  }
}



edd_plot_branch_pd_ed <- function(rates, stat_branch, params, offset = NULL, save_plot = FALSE, path = NULL) {
  lambda_num <- rates[1]
  mu_num <- rates[2]

  lambda <- as.character(rates[1])
  mu <- as.character(rates[2])
  offset_char <- as.character(offset)

  plot_data_pd <- dplyr::filter(stat_branch,
                                lambda == lambda_num &
                                  mu == mu_num &
                                  metric == "pd" &
                                  offset == offset_char)

  plot_data_ed <- dplyr::filter(stat_branch,
                                lambda == lambda_num &
                                  mu == mu_num &
                                  metric == "ed")

  plot_data_nnd <- dplyr::filter(stat_branch,
                                lambda == lambda_num &
                                  mu == mu_num &
                                  metric == "nnd")

  plot_data <- rbind(plot_data_pd, plot_data_ed, plot_data_nnd)

  mbl_plot <- ggplot2::ggplot(plot_data) +
    ggplot2::geom_boxplot(ggplot2::aes(beta_phi, mbl, fill = metric)) +
    ggplot2::facet_wrap(. ~ beta_n) +
    ggplot2::scale_y_continuous() +
    ggplot2::ylab("Mean branch length") +
    ggplot2::theme(axis.title.x = ggplot2::element_blank(),
                   axis.text.x = ggplot2::element_blank(),
                   axis.ticks.x = ggplot2::element_blank(),
                   axis.line.x = ggplot2::element_blank())

  pd_plot <- ggplot2::ggplot(plot_data) +
    ggplot2::geom_boxplot(ggplot2::aes(beta_phi, pd, fill = metric)) +
    ggplot2::facet_wrap(. ~ beta_n) +
    ggplot2::scale_y_continuous(trans = "log2") +
    ggplot2::ylab("Phylogenetic diversity") +
    ggplot2::theme(axis.title.x = ggplot2::element_blank(),
                   axis.text.x = ggplot2::element_blank(),
                   axis.ticks.x = ggplot2::element_blank(),
                   axis.line.x = ggplot2::element_blank(),
                   strip.background = ggplot2::element_blank(),
                   strip.text.x = ggplot2::element_blank())

  mntd_plot <- ggplot2::ggplot(plot_data) +
    ggplot2::geom_boxplot(ggplot2::aes(beta_phi, mntd, fill = metric)) +
    ggplot2::facet_wrap(. ~ beta_n) +
    #ggplot2::scale_y_continuous(trans = "sqrt") +
    ggplot2::scale_x_discrete(labels = format(unique(params$beta_phi), scientific = FALSE)) +
    ggplot2::ylab("Mean nearest taxon index") +
    ggplot2::xlab(expression(beta[italic(Phi)])) +
    ggplot2::theme(strip.background = ggplot2::element_blank(),
                   strip.text.x = ggplot2::element_blank())

  pd_ed_plot <- mbl_plot +
    ggplot2::ggtitle(bquote("Branching metrices, comparisons between PD (" ~ .(offset) ~ "), ED and NND, " ~ lambda ~ "=" ~ .(lambda) ~ mu ~ "=" ~ .(mu))) +
    pd_plot +
    mntd_plot +
    patchwork::plot_layout(nrow = 3, guides = "collect") &
    ggplot2::labs(fill = "Metric")

  if (save_plot == TRUE) {
    save_with_rates_offset(rates = rates,
                    offset = offset,
                    plot = pd_ed_plot,
                    which = "branch_pd_ed",
                    path = path,
                    device = "png",
                    width = 10, height = 8,
                    dpi = "retina")
  } else {
    return(pd_ed_plot)
  }
}



edd_plot_branch_significance <- function(params, stat_branch, save_plot = FALSE, path = NULL) {
  plot_data <- stat_branch %>%
    dplyr::filter(!(metric == "pd" & offset != "Simulation time")) %>%
    dplyr::filter(lambda == params$lambda & mu == params$mu & beta_n == params$beta_n & beta_phi == params$beta_phi) %>%
    tidyr::gather(key = "measure", value = "value", mbl, pd, mntd)
  plot_branch <- ggstatsplot::grouped_ggbetweenstats(x = metric,
                                                     y = value,
                                                     data = plot_data,
                                                     grouping.var = measure,
                                                     pairwise.comparisons = FALSE,
                                                     results.subtitle = FALSE,
                                                     subtitle = FALSE,
                                                     bf.message = FALSE,
                                                     caption = FALSE)

  if (save_plot == TRUE) {
    save_with_parameters(pars_list = params,
                         plot = plot_branch,
                         which = "branch_signif",
                         path = path,
                         device = "png",
                         width = 12,
                         height = 5,
                         dpi = "retina")
  } else {
    return(plot_branch)
  }
}
